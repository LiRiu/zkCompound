//@ts-ignore
import { BigInt, Bytes, Event } from "@hyperoracle/zkgraph-lib";
import {
  Configs
} from "./static/tokens";

import {
  updateConfigWithEvent
} from "./modules/configUpdater";
import { updateCloseFactor, updateCollateralFactor } from "./modules/factorUpdater";
import { calculateTotalValue, calculateTotalPrincipal, updatePrices } from "./modules/assetAggregator";
import { Result } from "./types/result";

/**
 * The idea of Compound Liquidator Automation is to monitor three types of events, 
 * namely NewCloseFactor, NewCollateralFactor, and Sync, 
 * in order to calculate whether the current user can be liquidated.
 *
 * @param {Event[]} events - The list of Event objects to handle.
 * @return {Bytes} The generated Bytes object.
 */
export function handleEvents(events: Event[]): Bytes {
  const configs = new Configs();
  // step1: If there is a NewCloseFactor or NewCollateralFactor event 
  // override the hardcoded Factor.
  let closeFactor = updateCloseFactor(events);
  updateCollateralFactor(configs, events);
  
  // step2: Update Balance and Principal by processing Mint Redeem Borrow Repay
  // Mint make balance +; Redeem make balance -
  // Borrow make principal +; Repay make Principal -
  updateConfigWithEvent(configs, events);

  // // step3: calculate totalValue and totalPrincipal
  // // totalValue += balance * price * COLLATERAL_FACTOR
  updatePrices(configs, events);
  const totalValue = calculateTotalValue(configs);
  const totalPrincipal = calculateTotalPrincipal(configs);
  // console.log("total value: " + totalValue.toString() + "U");
  // console.log("total principal: " + totalPrincipal.toString() + "U");

  // // step4: return totalValue <= totalPrincipal
  const shouldBeLiquidated = totalValue < totalPrincipal;
  return new Result(shouldBeLiquidated, configs.userAddress).toBytes();
}
